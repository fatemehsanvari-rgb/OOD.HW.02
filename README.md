تمرین دوم طراحی شی گرایی سیستم ها

گام اول : تشخیص زیرمسائل و الگوها
======

زیرمسئله ۱ : دریافت درخواست از کانال‌های مختلف

الف) شرح زیرمسئله :  
در سیستم پشتیبانی، درخواست‌های جدید می‌توانند از کانال‌های مختلفی مانند WEB یا EMAIL وارد سیستم شوند. با وجود تفاوت در کانال ورودی، در نهایت یک شیء از نوع درخواست پشتیبانی (Ticket) باید ایجاد شود. نحوه ایجاد و مقداردهی اولیه این درخواست ممکن است بسته به کانال ورودی متفاوت باشد.  
ب) الگوی پیشنهادی و دلیل انتخاب آن :  
Factory Pattern زیرا :  
منطق ایجاد شیء از نوع Ticket وابسته به شرایط (کانال ورودی) است.  
باید فرآیند ساخت شیء از منطق اصلی سیستم جدا شود.  
افزودن کانال جدید نباید باعث تغییر در کدهای موجود شود.  
ج) روش اعمال الگو :  
یک کلاس Factory تعریف می‌شود که مسئول ایجاد Ticket است. این کلاس بر اساس نوع کانال ورودی، نمونه مناسب Ticket را ایجاد و بازمی‌گرداند. کلاس‌های دیگر سیستم به‌جای استفاده مستقیم از new، از Factory برای دریافت شیء استفاده می‌کنند.

زیرمسئله ۲ : تعیین واحد مسئول رسیدگی به درخواست

الف) شرح زیرمسئله :  
پس از دریافت درخواست، سیستم باید بر اساس نوع درخواست تصمیم بگیرد که کدام واحد یا مسئول، مسئول رسیدگی به آن است. این تصمیم می‌تواند در آینده تغییر کند یا پیچیده‌تر شود. بنابراین، منطق تعیین مسئول رسیدگی نباید به‌صورت ثابت و مستقیم در بدنه اصلی سیستم پیاده‌سازی شود.  
ب) روش اعمال الگو و دلیل انتخاب آن :  
Strategy Pattern زیرا :  
یک تصمیم‌گیری (Assignment) می‌تواند با الگوریتم‌های مختلف انجام شود.  
الگوریتم‌ها باید قابل تعویض و توسعه باشند.  
سیستم نباید به پیاده‌سازی خاص یک روش وابسته باشد.  
ج) روش اعمال الگو :  
یک interface برای استراتژی تعیین مسئول تعریف می‌شود. برای هر نوع درخواست، یک پیاده‌سازی متفاوت از این interface وجود دارد. سیستم در زمان اجرا، Strategy مناسب را انتخاب کرده و برای تعیین واحد مسئول از آن استفاده می‌کند.

زیرمسئله ۳ : پاسخ‌دهی به درخواست‌ها

الف) شرح زیرمسئله :  
در طول فرآیند رسیدگی به درخواست، سیستم باید پاسخ مناسبی برای آن ارسال کند. نوع پاسخ بسته به نوع درخواست متفاوت است؛ برای مثال، پاسخ به یک درخواست فنی با پاسخ به یک درخواست عمومی متفاوت خواهد بود.  
ب) روش اعمال الگو و دلیل انتخاب آن :  
Strategy Pattern زیرا :  
عملیات پاسخ‌دهی یک رفتار متغیر است.  
هر نوع درخواست می‌تواند روش پاسخ‌دهی خاص خود را داشته باشد.  
افزودن نوع پاسخ جدید نباید منجر به تغییر در کدهای قبلی شود.  
ج) روش اعمال الگو :  
یک interface برای پاسخ‌دهی تعریف می‌شود و برای هر نوع پاسخ، یک کلاس مجزا پیاده‌سازی می‌شود. در زمان پردازش درخواست، Strategy مناسب انتخاب شده و عملیات پاسخ‌دهی از طریق آن انجام می‌شود.  

زیرمسئله ۴ : مدیریت وضعیت‌های درخواست

الف) شرح زیرمسئله :  
هر درخواست پشتیبانی در طول عمر خود از چند وضعیت متوالی عبور می‌کند، مانند ایجاد شدن، ارجاع داده شدن، در حال رسیدگی، حل شدن و بسته شدن. رفتار سیستم در هر یک از این وضعیت‌ها متفاوت است و انجام برخی عملیات تنها در وضعیت‌های خاص مجاز است.  
ب) روش اعمال الگو و دلیل انتخاب آن :  
State Pattern زیرا :  
رفتار سیستم وابسته به وضعیت فعلی درخواست است.  
وضعیت‌ها قابل تغییر و توسعه هستند.  
منطق هر وضعیت باید به‌صورت مجزا نگهداری شود.  
ج) روش اعمال الگو :  
یک interface یا کلاس انتزاعی برای وضعیت تعریف می‌شود. هر وضعیت به‌صورت یک کلاس جداگانه پیاده‌سازی می‌شود. کلاس Ticket وضعیت فعلی خود را نگهداری کرده و رفتارها را به شیء وضعیت فعلی واگذار می‌کند.  

زیرمسئله ۵ : ثبت رویدادهای سیستم

الف) شرح زیرمسئله :  
پس از پایان پردازش هر درخواست، لازم است یک پیام ثبت (Log) از انجام عملیات در سیستم ذخیره شود. ثبت رویداد یک رفتار جانبی است و نباید باعث وابستگی منطق اصلی سیستم به جزئیات ثبت لاگ شود، زیرا ممکن است در آینده نحوه ثبت رویداد تغییر کند.  
ب) روش اعمال الگو و دلیل انتخاب آن :  
Observer Pattern زیرا :  
ثبت رویداد وابسته به وقوع یک رویداد در سیستم است.  
منطق اصلی سیستم نباید به نحوه ثبت لاگ وابسته باشد.  
امکان اضافه کردن Listenerهای جدید بدون تغییر در منبع رویداد وجود دارد.   
ج) روش اعمال الگو :  
کلاس Ticket یا سرویس پردازش درخواست به‌عنوان Subject در نظر گرفته می‌شود. Observerهایی برای ثبت لاگ تعریف می‌شوند که هنگام وقوع رویدادهای مهم (مانند پایان پردازش یا تغییر وضعیت) فراخوانی می‌شوند.

گام دوم : ترسیم  class diagram
=======
لینک تصویر مربوطه : https://github.com/fatemehsanvari-rgb/OOD.HW.02/blob/f100714a27257214ff548ff51b375fffaef294a5/classdiagram.drawio.png

گام سوم : اعمال الگو
=======
الگوهایی که در گام اول شرح داده شد، بر روی کد ها اعمال گردید و بازآرایی شد.  
الگوی Factory باعث ایجاد پکیج Factory شده که ساخت Ticket به کلاس TicketFactory واگذار شد.  
برای الگوی State پکیجی به همین نام ساخته شد که وظیفه آن تعیین کردن رفتار Ticket بر اساس وضعیت فعلی است.  
از الگوی Strategy در دو قسمت استفاده شده است. که بخش اول آن در تعیین واحد مسئول رسیدگی به درخواست‌ها است تا امکان تغییر و توسعه الگوریتم تعیین مسئول بدون تغییر در منطق اصلی سیستم فراهم شود. بخش دیگر آن برای پاسخ دهی به درخواست ها باتوجه به نوع آن ها است که از الگوی Strategy استفاده شده تا نحوه پاسخ دهی به صورت پویا و قابل توسعه تعیین شود.  
الگوی Observer برای ثبت رویداد پس از پردازش درخواست استفاده شده تا منطق ثبت log از منطق اصلی سیستم جدا شود و امکان افزودن Listener جدید بدون تغییر Ticket فراهم شود. 
 
